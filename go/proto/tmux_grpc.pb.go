// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0
// source: proto/tmux.proto

package tmuxproto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TmuxService_StreamPane_FullMethodName    = "/mcp.tmux.v1.TmuxService/StreamPane"
	TmuxService_Snapshot_FullMethodName      = "/mcp.tmux.v1.TmuxService/Snapshot"
	TmuxService_CapturePane_FullMethodName   = "/mcp.tmux.v1.TmuxService/CapturePane"
	TmuxService_RunCommand_FullMethodName    = "/mcp.tmux.v1.TmuxService/RunCommand"
	TmuxService_SendKeys_FullMethodName      = "/mcp.tmux.v1.TmuxService/SendKeys"
	TmuxService_RunBatch_FullMethodName      = "/mcp.tmux.v1.TmuxService/RunBatch"
	TmuxService_MultiRun_FullMethodName      = "/mcp.tmux.v1.TmuxService/MultiRun"
	TmuxService_BatchCapture_FullMethodName  = "/mcp.tmux.v1.TmuxService/BatchCapture"
	TmuxService_TailPane_FullMethodName      = "/mcp.tmux.v1.TmuxService/TailPane"
	TmuxService_CaptureLayout_FullMethodName = "/mcp.tmux.v1.TmuxService/CaptureLayout"
	TmuxService_RestoreLayout_FullMethodName = "/mcp.tmux.v1.TmuxService/RestoreLayout"
	TmuxService_NewSession_FullMethodName    = "/mcp.tmux.v1.TmuxService/NewSession"
	TmuxService_NewWindow_FullMethodName     = "/mcp.tmux.v1.TmuxService/NewWindow"
	TmuxService_ServerInfo_FullMethodName    = "/mcp.tmux.v1.TmuxService/ServerInfo"
	TmuxService_ListDefaults_FullMethodName  = "/mcp.tmux.v1.TmuxService/ListDefaults"
	TmuxService_ValidateHost_FullMethodName  = "/mcp.tmux.v1.TmuxService/ValidateHost"
	TmuxService_ListSessions_FullMethodName  = "/mcp.tmux.v1.TmuxService/ListSessions"
	TmuxService_ListWindows_FullMethodName   = "/mcp.tmux.v1.TmuxService/ListWindows"
	TmuxService_ListPanes_FullMethodName     = "/mcp.tmux.v1.TmuxService/ListPanes"
	TmuxService_SetDefault_FullMethodName    = "/mcp.tmux.v1.TmuxService/SetDefault"
)

// TmuxServiceClient is the client API for TmuxService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TmuxServiceClient interface {
	StreamPane(ctx context.Context, in *StreamPaneRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaneChunk], error)
	Snapshot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error)
	CapturePane(ctx context.Context, in *CapturePaneRequest, opts ...grpc.CallOption) (*CapturePaneResponse, error)
	RunCommand(ctx context.Context, in *RunCommandRequest, opts ...grpc.CallOption) (*RunCommandResponse, error)
	SendKeys(ctx context.Context, in *SendKeysRequest, opts ...grpc.CallOption) (*SendKeysResponse, error)
	RunBatch(ctx context.Context, in *RunBatchRequest, opts ...grpc.CallOption) (*RunBatchResponse, error)
	MultiRun(ctx context.Context, in *MultiRunRequest, opts ...grpc.CallOption) (*MultiRunResponse, error)
	BatchCapture(ctx context.Context, in *BatchCaptureRequest, opts ...grpc.CallOption) (*BatchCaptureResponse, error)
	TailPane(ctx context.Context, in *TailPaneRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TailChunk], error)
	CaptureLayout(ctx context.Context, in *CaptureLayoutRequest, opts ...grpc.CallOption) (*CaptureLayoutResponse, error)
	RestoreLayout(ctx context.Context, in *RestoreLayoutRequest, opts ...grpc.CallOption) (*RestoreLayoutResponse, error)
	NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*NewSessionResponse, error)
	NewWindow(ctx context.Context, in *NewWindowRequest, opts ...grpc.CallOption) (*NewWindowResponse, error)
	ServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error)
	ListDefaults(ctx context.Context, in *ListDefaultsRequest, opts ...grpc.CallOption) (*ListDefaultsResponse, error)
	ValidateHost(ctx context.Context, in *ValidateHostRequest, opts ...grpc.CallOption) (*ValidateHostResponse, error)
	ListSessions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	ListWindows(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	ListPanes(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error)
	SetDefault(ctx context.Context, in *SetDefaultRequest, opts ...grpc.CallOption) (*SetDefaultResponse, error)
}

type tmuxServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTmuxServiceClient(cc grpc.ClientConnInterface) TmuxServiceClient {
	return &tmuxServiceClient{cc}
}

func (c *tmuxServiceClient) StreamPane(ctx context.Context, in *StreamPaneRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PaneChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TmuxService_ServiceDesc.Streams[0], TmuxService_StreamPane_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[StreamPaneRequest, PaneChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TmuxService_StreamPaneClient = grpc.ServerStreamingClient[PaneChunk]

func (c *tmuxServiceClient) Snapshot(ctx context.Context, in *SnapshotRequest, opts ...grpc.CallOption) (*SnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SnapshotResponse)
	err := c.cc.Invoke(ctx, TmuxService_Snapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) CapturePane(ctx context.Context, in *CapturePaneRequest, opts ...grpc.CallOption) (*CapturePaneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CapturePaneResponse)
	err := c.cc.Invoke(ctx, TmuxService_CapturePane_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) RunCommand(ctx context.Context, in *RunCommandRequest, opts ...grpc.CallOption) (*RunCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunCommandResponse)
	err := c.cc.Invoke(ctx, TmuxService_RunCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) SendKeys(ctx context.Context, in *SendKeysRequest, opts ...grpc.CallOption) (*SendKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendKeysResponse)
	err := c.cc.Invoke(ctx, TmuxService_SendKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) RunBatch(ctx context.Context, in *RunBatchRequest, opts ...grpc.CallOption) (*RunBatchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunBatchResponse)
	err := c.cc.Invoke(ctx, TmuxService_RunBatch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) MultiRun(ctx context.Context, in *MultiRunRequest, opts ...grpc.CallOption) (*MultiRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MultiRunResponse)
	err := c.cc.Invoke(ctx, TmuxService_MultiRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) BatchCapture(ctx context.Context, in *BatchCaptureRequest, opts ...grpc.CallOption) (*BatchCaptureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BatchCaptureResponse)
	err := c.cc.Invoke(ctx, TmuxService_BatchCapture_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) TailPane(ctx context.Context, in *TailPaneRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TailChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TmuxService_ServiceDesc.Streams[1], TmuxService_TailPane_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[TailPaneRequest, TailChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TmuxService_TailPaneClient = grpc.ServerStreamingClient[TailChunk]

func (c *tmuxServiceClient) CaptureLayout(ctx context.Context, in *CaptureLayoutRequest, opts ...grpc.CallOption) (*CaptureLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CaptureLayoutResponse)
	err := c.cc.Invoke(ctx, TmuxService_CaptureLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) RestoreLayout(ctx context.Context, in *RestoreLayoutRequest, opts ...grpc.CallOption) (*RestoreLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RestoreLayoutResponse)
	err := c.cc.Invoke(ctx, TmuxService_RestoreLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) NewSession(ctx context.Context, in *NewSessionRequest, opts ...grpc.CallOption) (*NewSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewSessionResponse)
	err := c.cc.Invoke(ctx, TmuxService_NewSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) NewWindow(ctx context.Context, in *NewWindowRequest, opts ...grpc.CallOption) (*NewWindowResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewWindowResponse)
	err := c.cc.Invoke(ctx, TmuxService_NewWindow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ServerInfo(ctx context.Context, in *ServerInfoRequest, opts ...grpc.CallOption) (*ServerInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerInfoResponse)
	err := c.cc.Invoke(ctx, TmuxService_ServerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ListDefaults(ctx context.Context, in *ListDefaultsRequest, opts ...grpc.CallOption) (*ListDefaultsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDefaultsResponse)
	err := c.cc.Invoke(ctx, TmuxService_ListDefaults_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ValidateHost(ctx context.Context, in *ValidateHostRequest, opts ...grpc.CallOption) (*ValidateHostResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateHostResponse)
	err := c.cc.Invoke(ctx, TmuxService_ValidateHost_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ListSessions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, TmuxService_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ListWindows(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, TmuxService_ListWindows_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) ListPanes(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListResponse)
	err := c.cc.Invoke(ctx, TmuxService_ListPanes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tmuxServiceClient) SetDefault(ctx context.Context, in *SetDefaultRequest, opts ...grpc.CallOption) (*SetDefaultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDefaultResponse)
	err := c.cc.Invoke(ctx, TmuxService_SetDefault_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TmuxServiceServer is the server API for TmuxService service.
// All implementations must embed UnimplementedTmuxServiceServer
// for forward compatibility.
type TmuxServiceServer interface {
	StreamPane(*StreamPaneRequest, grpc.ServerStreamingServer[PaneChunk]) error
	Snapshot(context.Context, *SnapshotRequest) (*SnapshotResponse, error)
	CapturePane(context.Context, *CapturePaneRequest) (*CapturePaneResponse, error)
	RunCommand(context.Context, *RunCommandRequest) (*RunCommandResponse, error)
	SendKeys(context.Context, *SendKeysRequest) (*SendKeysResponse, error)
	RunBatch(context.Context, *RunBatchRequest) (*RunBatchResponse, error)
	MultiRun(context.Context, *MultiRunRequest) (*MultiRunResponse, error)
	BatchCapture(context.Context, *BatchCaptureRequest) (*BatchCaptureResponse, error)
	TailPane(*TailPaneRequest, grpc.ServerStreamingServer[TailChunk]) error
	CaptureLayout(context.Context, *CaptureLayoutRequest) (*CaptureLayoutResponse, error)
	RestoreLayout(context.Context, *RestoreLayoutRequest) (*RestoreLayoutResponse, error)
	NewSession(context.Context, *NewSessionRequest) (*NewSessionResponse, error)
	NewWindow(context.Context, *NewWindowRequest) (*NewWindowResponse, error)
	ServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error)
	ListDefaults(context.Context, *ListDefaultsRequest) (*ListDefaultsResponse, error)
	ValidateHost(context.Context, *ValidateHostRequest) (*ValidateHostResponse, error)
	ListSessions(context.Context, *ListRequest) (*ListResponse, error)
	ListWindows(context.Context, *ListRequest) (*ListResponse, error)
	ListPanes(context.Context, *ListRequest) (*ListResponse, error)
	SetDefault(context.Context, *SetDefaultRequest) (*SetDefaultResponse, error)
	mustEmbedUnimplementedTmuxServiceServer()
}

// UnimplementedTmuxServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTmuxServiceServer struct{}

func (UnimplementedTmuxServiceServer) StreamPane(*StreamPaneRequest, grpc.ServerStreamingServer[PaneChunk]) error {
	return status.Errorf(codes.Unimplemented, "method StreamPane not implemented")
}
func (UnimplementedTmuxServiceServer) Snapshot(context.Context, *SnapshotRequest) (*SnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Snapshot not implemented")
}
func (UnimplementedTmuxServiceServer) CapturePane(context.Context, *CapturePaneRequest) (*CapturePaneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CapturePane not implemented")
}
func (UnimplementedTmuxServiceServer) RunCommand(context.Context, *RunCommandRequest) (*RunCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCommand not implemented")
}
func (UnimplementedTmuxServiceServer) SendKeys(context.Context, *SendKeysRequest) (*SendKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendKeys not implemented")
}
func (UnimplementedTmuxServiceServer) RunBatch(context.Context, *RunBatchRequest) (*RunBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunBatch not implemented")
}
func (UnimplementedTmuxServiceServer) MultiRun(context.Context, *MultiRunRequest) (*MultiRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiRun not implemented")
}
func (UnimplementedTmuxServiceServer) BatchCapture(context.Context, *BatchCaptureRequest) (*BatchCaptureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCapture not implemented")
}
func (UnimplementedTmuxServiceServer) TailPane(*TailPaneRequest, grpc.ServerStreamingServer[TailChunk]) error {
	return status.Errorf(codes.Unimplemented, "method TailPane not implemented")
}
func (UnimplementedTmuxServiceServer) CaptureLayout(context.Context, *CaptureLayoutRequest) (*CaptureLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CaptureLayout not implemented")
}
func (UnimplementedTmuxServiceServer) RestoreLayout(context.Context, *RestoreLayoutRequest) (*RestoreLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestoreLayout not implemented")
}
func (UnimplementedTmuxServiceServer) NewSession(context.Context, *NewSessionRequest) (*NewSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSession not implemented")
}
func (UnimplementedTmuxServiceServer) NewWindow(context.Context, *NewWindowRequest) (*NewWindowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewWindow not implemented")
}
func (UnimplementedTmuxServiceServer) ServerInfo(context.Context, *ServerInfoRequest) (*ServerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ServerInfo not implemented")
}
func (UnimplementedTmuxServiceServer) ListDefaults(context.Context, *ListDefaultsRequest) (*ListDefaultsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDefaults not implemented")
}
func (UnimplementedTmuxServiceServer) ValidateHost(context.Context, *ValidateHostRequest) (*ValidateHostResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateHost not implemented")
}
func (UnimplementedTmuxServiceServer) ListSessions(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedTmuxServiceServer) ListWindows(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListWindows not implemented")
}
func (UnimplementedTmuxServiceServer) ListPanes(context.Context, *ListRequest) (*ListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPanes not implemented")
}
func (UnimplementedTmuxServiceServer) SetDefault(context.Context, *SetDefaultRequest) (*SetDefaultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefault not implemented")
}
func (UnimplementedTmuxServiceServer) mustEmbedUnimplementedTmuxServiceServer() {}
func (UnimplementedTmuxServiceServer) testEmbeddedByValue()                     {}

// UnsafeTmuxServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TmuxServiceServer will
// result in compilation errors.
type UnsafeTmuxServiceServer interface {
	mustEmbedUnimplementedTmuxServiceServer()
}

func RegisterTmuxServiceServer(s grpc.ServiceRegistrar, srv TmuxServiceServer) {
	// If the following call pancis, it indicates UnimplementedTmuxServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TmuxService_ServiceDesc, srv)
}

func _TmuxService_StreamPane_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamPaneRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TmuxServiceServer).StreamPane(m, &grpc.GenericServerStream[StreamPaneRequest, PaneChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TmuxService_StreamPaneServer = grpc.ServerStreamingServer[PaneChunk]

func _TmuxService_Snapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).Snapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_Snapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).Snapshot(ctx, req.(*SnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_CapturePane_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapturePaneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).CapturePane(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_CapturePane_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).CapturePane(ctx, req.(*CapturePaneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_RunCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).RunCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_RunCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).RunCommand(ctx, req.(*RunCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_SendKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).SendKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_SendKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).SendKeys(ctx, req.(*SendKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_RunBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).RunBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_RunBatch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).RunBatch(ctx, req.(*RunBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_MultiRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).MultiRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_MultiRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).MultiRun(ctx, req.(*MultiRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_BatchCapture_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCaptureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).BatchCapture(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_BatchCapture_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).BatchCapture(ctx, req.(*BatchCaptureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_TailPane_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TailPaneRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TmuxServiceServer).TailPane(m, &grpc.GenericServerStream[TailPaneRequest, TailChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TmuxService_TailPaneServer = grpc.ServerStreamingServer[TailChunk]

func _TmuxService_CaptureLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CaptureLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).CaptureLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_CaptureLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).CaptureLayout(ctx, req.(*CaptureLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_RestoreLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestoreLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).RestoreLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_RestoreLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).RestoreLayout(ctx, req.(*RestoreLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_NewSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).NewSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_NewSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).NewSession(ctx, req.(*NewSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_NewWindow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewWindowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).NewWindow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_NewWindow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).NewWindow(ctx, req.(*NewWindowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ServerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ServerInfo(ctx, req.(*ServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ListDefaults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDefaultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ListDefaults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ListDefaults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ListDefaults(ctx, req.(*ListDefaultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ValidateHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateHostRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ValidateHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ValidateHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ValidateHost(ctx, req.(*ValidateHostRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ListSessions(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ListWindows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ListWindows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ListWindows_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ListWindows(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_ListPanes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).ListPanes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_ListPanes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).ListPanes(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TmuxService_SetDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TmuxServiceServer).SetDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TmuxService_SetDefault_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TmuxServiceServer).SetDefault(ctx, req.(*SetDefaultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TmuxService_ServiceDesc is the grpc.ServiceDesc for TmuxService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TmuxService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "mcp.tmux.v1.TmuxService",
	HandlerType: (*TmuxServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Snapshot",
			Handler:    _TmuxService_Snapshot_Handler,
		},
		{
			MethodName: "CapturePane",
			Handler:    _TmuxService_CapturePane_Handler,
		},
		{
			MethodName: "RunCommand",
			Handler:    _TmuxService_RunCommand_Handler,
		},
		{
			MethodName: "SendKeys",
			Handler:    _TmuxService_SendKeys_Handler,
		},
		{
			MethodName: "RunBatch",
			Handler:    _TmuxService_RunBatch_Handler,
		},
		{
			MethodName: "MultiRun",
			Handler:    _TmuxService_MultiRun_Handler,
		},
		{
			MethodName: "BatchCapture",
			Handler:    _TmuxService_BatchCapture_Handler,
		},
		{
			MethodName: "CaptureLayout",
			Handler:    _TmuxService_CaptureLayout_Handler,
		},
		{
			MethodName: "RestoreLayout",
			Handler:    _TmuxService_RestoreLayout_Handler,
		},
		{
			MethodName: "NewSession",
			Handler:    _TmuxService_NewSession_Handler,
		},
		{
			MethodName: "NewWindow",
			Handler:    _TmuxService_NewWindow_Handler,
		},
		{
			MethodName: "ServerInfo",
			Handler:    _TmuxService_ServerInfo_Handler,
		},
		{
			MethodName: "ListDefaults",
			Handler:    _TmuxService_ListDefaults_Handler,
		},
		{
			MethodName: "ValidateHost",
			Handler:    _TmuxService_ValidateHost_Handler,
		},
		{
			MethodName: "ListSessions",
			Handler:    _TmuxService_ListSessions_Handler,
		},
		{
			MethodName: "ListWindows",
			Handler:    _TmuxService_ListWindows_Handler,
		},
		{
			MethodName: "ListPanes",
			Handler:    _TmuxService_ListPanes_Handler,
		},
		{
			MethodName: "SetDefault",
			Handler:    _TmuxService_SetDefault_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPane",
			Handler:       _TmuxService_StreamPane_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TailPane",
			Handler:       _TmuxService_TailPane_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/tmux.proto",
}
